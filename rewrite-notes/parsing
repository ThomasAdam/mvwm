Overview of fvwm2 parsing as of 16-Aug-2014
===========================================

Sources of input to parse
-------------------------

 * Configuration files and files read with the Read command
   - May be preprocessed by FvwmCpp or FvwmM4

 * Input from the PipeRead command

 * Input from modules to fvwm through the module pipes

   - Fixed or generated strings from modules (e.g. FvwmPager,
     FvwmButtons etc.)

   - User input, e.g. from FvwmConsole or FvwmCommand.

 * Module input from fvwm through the module pipes is parsed by
   the receiving module.

   - Binary input in predefined packets is only partially parsed
     (packet type).  The format and meaning of the packets is a
     property of the module protocol.

   - The payload of some string packets (e.g. generated by the
     SendToModule command) is a free form string that is
     interpreted by the receiving module.  The module does any
     necessary parsing.  Example:

       SendToModule FvwmButtons changebutton 0 title foo, activetitle bar

 * Commands generated internally by fvwm as the result of an
   external event, for example, an Ewmh message.  This is used
   quite often; instead of calling the function to maximize a
   window directly, one may generate a command string that is
   passed to execute_function().  Examples are
   virtual.c:CMD_EdgeResistance() or
   ewmh_events.c:ewmh_DesktopGeometry().

Various properties of parser input and the communication channels
-----------------------------------------------------------------

 * Maximum length of of lines read from a file is hard coded ro
   1024 bytes in read.c:run_command_stream().  This is applicable
   to configuration files and the Read and Piperead commands.

 * The maximum depth of nested files opened through the Read
   command is hard coded to 40 (read.c).

 * Input from files or the PipeRead command may have an unlimited
   number of lines.

 * The maximum length of packets that can be sent in one chunk
   from fvwm to the modules or back is hard coded to 256 including
   the packet header (FvwmPacketMaxSize in Module.h).  This is an
   artifact of module communication through pipes.  256 bytes is
   the size that all systems guarantee to be sent through the pipe
   in an atomic block.

   Anything larger than that may be split into multiple write
   calls, leading to mutilated messages in either direction.
   Packets from fvwm to the modules are simply truncated to 256
   bytes (module_interface.c:make_vpacket()).  Packets from the
   modules to fvwm are possibly sent in multiple pieces (write
   call in Module.c:SendText()).  Fvwm can theoretically handle
   any size of module input (module_list.c:module_receive()).

 * Input from modules to fvwm is pre-parsed in
   module_interface.c:module_input_execute(), i.e. fvwm checks
   whether the command name of the packet is "popup" and does some
   special processing if that is the case (this command name is
   not to be confused with the command from the text to be
   executed by fvwm; its a fixed field in the packet).  This is
   done before any regular processing of the input.

 * Input from the modules is not executed right away but stored in
   a queue and executed when fvwm can process it (this is
   important because otherwise module input might interfere with
   function execution) (module_interface.c:ExecuteCommandQueue()).

Fvwm's central parsing function: execute_function()
---------------------------------------------------

 * All input to the parser is passed through
   functions.c:__execute_function().  This function is slightly
   mis-named.  A better name would be _execute_command_line().

 * __execute_function is called from two places:

   - execute_function() is just a wrapper exported rom
     functions.c.  There are two more wrappers,
     execute_function_override_wcontext() and
     execute_function_override_window() which change the execution
     context of the command (see below) and then call
     execute_function().

   - __run_complex_function_items() calls __execute_function() to
     process the individual commands of a complex function.  In
     other words: The items of a complex function are passed twice
     through the parser.  First when the complex function is
     defined, and a second time when they are executed (they are
     treated differently in both passes, see further down).

 * The call to __execute_function() is passed various pieces of
   information:

      void __execute_function(
	cond_rc_t *cond_rc,
        const exec_context_t *exc,
        char *action,
	FUNC_FLAGS_TYPE exec_flags,
        char *args[],
        Bool has_ref_window_moved)

    - cond_rc is a pointer to memory where the return code of
      command line execution is to be stored.  This can be used in
      scripting through complex functions
      (__run_complex_function_items()) and by the internal caller
      of execute_function.  It is also one of the parameters of
      the CMD_... functions, and it's important that cond_rc is
      passed around and not set to a NULL pointer except by the
      first call triggering command line processing.

    - exc is the execution context of the command line
      (execcontext.h).  This is a vital data structure for command
      line processing and execution.  It contains information
      about the originator of the command and the assiciated
      application (type (module, event, scheduler, ...), the
      actual X event, the module, the window).  This data is used
      during command execution, e.g. to identify the window on
      which a command is executed or to determine the pointer
      position; some commands work differently when input comes
      from the mouse or the keyboard.  It is also used during
      variable expansion (e.g. to expand window related extended
      parameters like $[w.id]).

      It is important to properly set the execution context
      whenever a command line is generated.  Currently, some of
      the Ewmh code fails to do so for historical reasons which I
      won't explain here.  This needs to be fixed eventually.

    - action is the command line to parse and execute.

    - exec_flags are flags that affect command parsing and
      execution that may become necessary in some contexts not
      related to the originator of the command.  The flags are
      defined in the structure execute_flags_t in functions.h.

      ~ FUNC_NEEDS_WINDOW commands that need a context window are
        not executed if it's missing.
      ~ FUNC_DONT_REPEAT the command line is not repeatable (see
        CMD_Repeat).
      ~ FUNC_ADD_TO signals that the command is the addtofunc or
        "+" command.
      ~ FUNC_DECOR signals that the command is a decor related
        command.
      ~ FUNC_ALLOW_UNMANAGED allows running a command with an
        overrideredirect window.
      ~ FUNC_IS_UNMANAGED signals that the context window is an
        overrideredirect window.
      ~ FUNC_DONT_EXPAND_COMMAND suppresses expansion of variables
        on the command line.
      ~ FUNC_DONT_DEFER suppresses deferring execution of commands
        that need a target window (normally these are put into the
        queue and processed later).

    - args is the array of the positional arguments during complex
      function execution.  For calls from execute_function() it's
      a NULL pointer.

    - has_ref_window_moved is a separate flag (hack) that triggers
      some special treatment of the execution of the command Move,
      Resize and AnimatedMove (but forgets the ResizeMove and
      ResizeMoveMaximize commands).  This should ratehr be stored
      in exec_flags.

Command line parsing
--------------------

The command independent parsing of any command line is done by the
__execute_function() call.  The parsing procedure is as follows.
Remember that "action" is the command line to be parsed.  The
pointer and the memory it points to are updated during the parsing
process.

Step 1
  Handle NULL pointer, whitespace and comments

   (a) Stop parsing and execute nothing if action is a NULL
       pointer.
       *DONE*
   (b) Strip all whitespace from the beginning of the command
       line.
   (c) Stop parsing and execute nothing if action is a NULL
       pointer or an empty string.  (Note that some of the
       functions in libs/Parse.c never return an empty string but
       rather a NULL pointer.  Parsing in the individual commands
       often relies on that.)
       *DONE*
   (d) If the first character is '#', is a comment.  Stop parsing
       and execute nothing.
       *DONE*

Step 2
   (a) Increment the nested function depth.
   (b) If the function depth is too high, print an error message
       and stop.
       *DONE*
   (c) Determine the context window.

Step 3
  Handle prefixes

   (a) If action begins with '-', set the FUNC_DONT_EXPAND_COMMAND
       flag and skip the '-' character.
   (b) Peek the first token of action.
   (c) If the token is "silent", set the global
       Scr.flags.are_functions_silent if not already set, strip
       the token from action and go back to (b).
   (d) If the token is "keeprc", set the internal do_keep_rc flag,
       strip the token from action and go back to (b).  (A dummy
       return code variable is used in the command execution.)

Step 4
   Finish if there is no remaining action to execute.

Step 5
  Parse the command token

   (a) Get (but not strip) the command token from the action.
   (b) Expand variables in the token (expand.c:expand_vars()).
   (c) If the token does not start with a '*':
       ~ strip all characters from and including the first
         whitespace from the command token.

         [Bug: Complex function names cannot have embedded
         whitespace because of this, see comment in the code.]

         [Note: If a command line begins with

           "*foo"

         (including the double quotes), the double quotes are
         removed by GetNextToken, and the remaining token does
         begin with '*'.]

       ~ find the internal command matching this token from the
         builtin function table.  Note that any token _beginning_
         with "+" or " +" is treated as the "+" command.

        [What the heck is this good for?]

Step 6
  If a we're currently adding to a decor, and the command token
  designates a builtin function that does not have the FUNC_DECOR
  flag set, generate a warning that the command cannot be added to
  the decor.

Step 7
  If the FUNC_DONT_EXPAND_COMMAND flag is not set, expand
  variables in the action, including the part from which the
  command token was extracted above.  (The ismod flag of the call
  to expand_vars() flag is set if the action begins with '*').

  [Note: The command token was parsed before expansion in step 5.
  Now the whole line including the token is expanded before
  further processing.  This may or may not cause subtle bugs with
  quoting and expansion.]

Step 8
  If the expanded action begins with '*' treat it as a module
  configuration line.
  *GOTO step 10*

  [BUG: Contrary to step 5 (c), a line beginning with

    "*foo"

  is not recognized as a module configuration line because it
  begins with double quotes, not '*'.]

Setp 9
  Execute the action

  (a) Prepare the execution context.
  (b) If it's a builtin function other than "Function", strip the
      first token from the expanded action and defer or execute
      the CMD_<command>() function as necessary with the proper
      execution context.
      *GOTO step 10*
  (c) If it's the builtin command "Function", strip the first
      token from the expanded action.

      [Note: this may again be a different substring than in step
      5 (c) or step 8.]
  (d) Call
      execute_complex_function with the remaining expanded action.
  (e) If no complex function with that name can be found and it
      was not the builtin command "Function", assume that the
      builtin command was "Module" and try to execute CMD_Module
      with the remaining expanded action as its arguments.

Step 10
  Cleanup

   (a) Clear the Scr.flags.are_functions_silent flag if set in
       step 3 (c).
   (b) Store the number of pending breaks from the functions
       return code structure in the original cond_rc (which may be
       a different one in case the command was prefixed with
       keeprc).
   (c) Decrement the nested function depth.

Tokenization
------------

The token parsing code is in libs/Parse.c:DoPeekToken() and
CopyToken() (called by the former).  DoPeekToken takes the input
string, a pointer to memory where it stores the pointer to the
resulting token, a pointer to memory to store the output string
(buffer with hardcoded length MAX_TOKEN_LENGTH = 1023 bytes
(Parse.h)), and may be provided a string of additional characters
to be treated as spaces, a string of input token delimiter
characters, and a pointer where the character that ended the token
is stored (output delimiter).  By default, the set of space
characters contains the character class determined by isspace(),
and the set of input delimiter characters is empty

Step 1 (DoPeekToken)
  (a) Strip all space characters (see above) from the beginning of
      the input string.
  (b) Call CopyToken() with the remaining string.

Step 2 (CopyToken)

  (a) Set the src pointer to the beginning of the input string.
      The dest pointer is passed in as a function argument.
  (b) If src is at the end of the string,
      *GOTO stp 3*
  (c) If *src is a space character or an input delimiter,
      *GOTO stp 3*
  (d) If *src is a quote character (either a double quote
      chararcter, a single quote or a backtick),
      *GOTO step 2A*
  (e) Otherwise,
      *GOTO step 2B*

Step 2A
  (a) c := *src
  (b) Skip over the src quote character (src++)
  (c) If *src is c or the end of string,
      *GOTO (f)*
  (d) If *src is a backslash and the next character is not the end
      of the input string (null byte), skip over the backslash in
      the input (src++).
  (e) If there's still room in the output string, copy *src to
      *dest and increment both pointers, otherwise just skip over
      the input character (src++).
      *GOTO (c)*
  (f) If *src is c, skip over it (src++).
      *GOTO step 2 (b)*

Step 2B
  (a) If *src is a backslash and the next character is not the end
      of the input string (null byte), skip over the backslash in
      the input (src++).
  (b) If there's still room in the output string, copy *src to
      *dest and increment both pointers, otherwise just skip over
      the input character (src++).
      *GOTO step 2 (b)*

Step 3
  (a) Set the output delimiter to the character pointer to by src
      (i.e. the first character after the token).
  (b) Terminate the destination string with a null byte.
  (d) If src points to a string of zero or more spaces followed by
      an input delimiter, store the delimiter as the output
      delimiter and return a pointer to the character after that.
  (e) Otherwise, if src is not at the end of the string, return
      the character after src.
  (f) Otherwise src points to the end of the string; return src.

Step 4 (DoPeekToken)
  (a) If the remaining string has the length zero, set the token
      pointer to NULL.
  (b) Return a pointer to the beginning of the next token in the
      input string.
      *DONE*

Variable expansion
------------------

Variable expansion is done expand.c:expand_vars().  The function
takes an input string, the execution context, cond_rc and an array
of positional parameters and returns the string with the variables
expanded.  It also takes the flags addto (never set) and ismod
(set in step 7 of the parsing algorithm if the command begins with
'*').

[BUG: The addto flag is actually never set when the function is
called but instead used as a bogus local variable.]

Step 1
  (a) l := length of input
  (b) If the input begins with '*', set the addto flag.
  (c) Calculate the length of the expanded string and allocate
      memory for it.

Step 2 (Scan for variables)
  (a) Begin at the start of the input and output strings.
  (b) Copy all character up to but excluding the next '$'
      character to the output string (stop at the end of string).
  (c) If we're at the end of the string, stop.
      *DONE*
  (d) Otherwise we're now at a '$' character.  If the ismod flag
      set and the next character is a letter, copy both to the
      output string.
      *GOTO (b)*

      [Note: In module configuration lines, variable in the form
      "$<letter>" are not expanded.  There are probably several
      bugs because of this logic.]

Step 3 (Expand a variable)
  (a) If the next character is a '$', copy one '$' to the output,
      skip over two '$' in the input and
      *GOTO step 2 (b)*
  (b) If the next character is '[',
      *GOTO step 4*
  (c) If the "$<character>" sequence does not designate a valid
      one character variable, copy it to the output and
      *GOTO step 2 (b)*
  (d) Otherwise, skip over the '$' and the next character in the
      input and copy the value of the one character variable to
      the output.
      *GOTO step 2 (b)*

Step 4 (Expand an extended variable)
  (a) If addto is set, copy the "$[" to the output and
      *GOTO step 2 (b)*
  (b) Determine the name of the extended variable.  The name
      starts after the initial '[' character and ends before the
      final ']' character.  The final ']' character is the first
      occurence of the character ']' after the '$', where the
      number of '[' minus the number of ']' is zero (i.e., square
      brackets can be nested).  If the end of string is
      encountered, just copy everything to the output and
      *GOTO step 2 (b)*
  (c) Otherwise, if the variable name contains at least one '$',
      call expand vars with the name to expand nested variable
      references.  The result of this expansion is taken as the
      new variable name.
  (d) If an extended variable with that name exists, copy its
      value into the output, skip the "$[...]" in the input and
      *GOTO step 2 (b)*
  (e) Otherwise copy the "$[...]" to the output and
      *GOTO step 2 (b)*

The second level of parsing
---------------------------

When __execute_function has finished its work it either tries to
execute a module, a builtin command or a complex function (or
nothing at all and just returns).  Module execution is treated
like a call of CMD_Module(), so there are two different ways how
parsing continues.  A third context of parsing is, when a module
receives a packet from fvwm.

 * Parsing of builtin commands is done individually by the
   CMD_<builtin>() functions.

 * Parsing and of a complex function call and its items is handled
   by the function functions.c:execute_complex_function().

 * Parsing of module configuration lines is done by the modules
   with help from libs/Modules.c.  There is also an optional step
   of module variable expansion that is implemented in
   Modules.c:module_expand_action().  It replaces some module
   variables in the string that is going to be sent to fvwm,
   e.g. "$width" or "$x".  FvwmButtons, FvwmIconMan and
   FvwmTaskBar and use this mechanism.

Parsing of complex function calls
---------------------------------

Implemented in functions.c:execute_complex_function().

Step 1
  (a) Peek the first token of the action.
  (b) Look it up in the list of complex functions.
  (c) If no such function exists, return an error.
      *DONE*
  (d) Split the action into tokens using GetNextToken.  Store the
      original action (without the function name) followed by the
      first ten tokens in the positional arguments array.
  (e) Set up an execution context for the function items.
  (f) Call __run_complex_function_items().

Step 2 (__run_complex_function_items())
  (a) For each complec function iten, call __execute_function()
      with the FUNC_DONT_DEFER flag and the list of positional
      arguments.  This causes the function item command text to be
      passed through the parser again.
  *DONE*

Parsing needs of the builtin commands
-------------------------------------

Note: Let's attempt to formulate the existing syntax in ABNF
(rfc5234).

Definitions that need defining for the below
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    * FLAG = !!!;
    * DECOR = !!!;
    * FONTNAME = !!!;
    * IMAGEFILE = !!!;
    * GRADIENT = !!!;
    * MOVEARGS = !!!;
    * MODULECONFIG = !!!;
    * CONDITION = !!!;
    * COLOUR_FG = !!!;
    * COLOUR_BG = !!!;
    * COMMAND = !!!; (builtin; can also be one of FUNCNAME)
    * FUNCNAME = !!!; (StartFunction | ExitFunction | etc, plus user-defined)
    * SHELL = !!!;
    * KEYNAME = !!!;
    * STYLEOPTION = !!!; (massive list of style options!!!)

Types
~~~~~

 WSC = %x20 / %x09
 WS = *WSC
 DIGIT = "0" / "1" / "2" / "3" / "4" / "5" / "6" / "7" / "8" / "9"
 SIGNPOS = "+"
 SIGNNEG = "-"
 SIGN = SIGNPOS / SIGNNEG
 POSINT = [SIGNPOS] 1*DIGIT
 INT = [SIGN] 1*DIGIT
 INTPERCENTAGE = 1DIGIT | 2DIGIT | ("0" / "1") 2DIGIT
 TRUE = "yes" / "y" / "1" / "t" / "true"
 FALSE = "no" / "n" / "0" / "f" / "false"
 BOOL = TRUE / FALSE
 TOGGLE = "toggle"
 BOOLOR_TOGGLE = BOOL / TOGGLE
 MODIFIERS = "s" / "c" / "l" / "m" / "1" / "2" / "3" / "4" / "5" / "a"
 BINDINGMODIFIERS = "n" / 1*MODIFIERS
 PATH = ["/"] *(STRING "/") [STRING]
 VISIBLE_NAME = !!!
 CLASS = !!!
 RESOURCE = !!!
 NAME = !!!
 WINDOW_ID = !!!
 WINDOWSELECTOR = VISIBLE_NAME / CLASS / RESOURCE / NAME / WINDOW_ID
 BINDINGCONTEXT = "R" / "W" / "D" / "T" / "F" / "A" / "S" / "M" / "I"
 BINDINGCONTEXT = "[" / "]" / "-" / "_"
 BINDINGCONTEXT = "<" / "^" / ">" / "v"
 BINDINGCONTEXT = DIGIT
 MODULENAME = "MvwmAnimate" / "MvwmButtons" / ...
 MODULALIAS = TOKEN
 DECORNAME = TOKEN
 FUNCNAME = TOKEN
 MENUNAME = TOKEN
 MENUSTYLENAME = TOKEN
 STYLENAME = TOKEN / "*"
 DIRS_MAIN = "North" / "N"
 DIRS_MAIN =/ "East" / "E"
 DIRS_MAIN =/ "South" / "S"
 DIRS_MAIN =/ "West" / "W"
 DIRS_DIAG = DIRS_MAIN
 DIRS_DIAG =/ "NorthEast" / "NW"
 DIRS_DIAG =/ "SouthEast" / "SE"
 DIRS_DIAG =/ "SouthWest" / "SW"
 DIRS_DIAG =/ "NorthWest" / "NW"
 DIRS_CENTER = DIRS_DIAG / "Center" / "C"
 COLORSET_NUM = POSINT
 BUTTON = 1*DIGIT
 SELECTCMDCONDITION =
	 *("CirculateHit" / "CirculateHitIcon" / "CirculateHitShaded") !!!

Commands
~~~~~~~~
CMD_ADDBUTTONSTYLE = "AddButtonStyle"
	ADDBUTTONSTYLEBUTTON [ADDBUTTONSTYLESTATE]
	[ADDBUTTONSTYLESTYLE] [ADDBUTTONSTYLEFLAG]
ADDBUTTONSTYLEBUTTON = POSINT ("All" / "Left" / "Right")
ADDBUTTONSTYLESTATE = "ActiveUp"
ADDBUTTONSTYLESTATE =/ "ActiveDown"
ADDBUTTONSTYLESTATE =/ "InactiveUp"
ADDBUTTONSTYLESTATE =/ "InactiveDown"
ADDBUTTONSTYLESTATE =/ ADDBUTTONSTYLEACTIVE
ADDBUTTONSTYLESTATE =/ "Inactive"
ADDBUTTONSTYLESTATE =/ TOGGLE
ADDBUTTONSTYLESTATE =/ "AllActive"
ADDBUTTONSTYLESTATE =/ "AllInactive"
ADDBUTTONSTYLESTATE =/ "AllNormal"
ADDBUTTONSTYLESTATE =/ "AllToggled"
ADDBUTTONSTYLESTATE =/ "AllUp"
ADDBUTTONSTYLESTATE =/ "AllDown"
ADDBUTTONSTYLESTATE =/ "AllActiveUp"
ADDBUTTONSTYLESTATE =/ "AllActiveDown"
ADDBUTTONSTYLESTATE =/ "AllInactiveUp"
ADDBUTTONSTYLESTATE =/ "AllInactiveDown"
ADDBUTTONSTYLEACTIVE = "Active" - implies FOCUSED_WINDOW
ADDBUTTONSTYLEFLAG = ["!"]ADDBUTTONSTYLEKEYWORD *(","  ["!"]ADDBUTTONSTYLEKEYWORD)
; (XXX = ButtonStyle relationships here...)

CMD_ADDTITLESTYLE = "AddTitleStyle" [ADDTITLESTYLESTATE]
	[ADDTITLESTYLESTYLE] [ADDTITLESTYLEFLAG]
ADDTITLESTYLESTATE = "ActiveUp"
ADDTITLESTYLESTATE =/ "ActiveDown"
ADDTITLESTYLESTATE =/ "InactiveUp"
ADDTITLESTYLESTATE =/ "InactiveDown"
ADDTITLESTYLESTATE =/ ADDTITLESTYLEACTIVE
ADDTITLESTYLESTATE =/ "Inactive"
ADDTITLESTYLESTATE =/ "toggled"
ADDTITLESTYLESTATE =/ "AllActive"
ADDTITLESTYLESTATE =/ "AllInactive"
ADDTITLESTYLEFLAG = ["!"] ADDTITLESTYLEFLAGKEYWORD *("," ["!"] ADDTITLESTYLEFLAGKEYWORD)
ADDTITLESTYLEACTIVE = "Active" ; - implies FOCUSED_WINDOW
; (XXX = TitleStyle/ButtonStyle relationships here...)

CMD_ADDTODECOR = "AddToDecor" DECORNAME
DECORNAME = TOKEN
; (XXX = Other commands/styles affect this document below first!)

CMD_ADDTOFUNC = "AddToFunc" FUNCNAME ADDTOFUNCFUNCDEFS RESTOFLINE_COMMAND
ADDTOFUNCFUNCDEFS = "I"
ADDTOFUNCFUNCDEFS =/ "M"
ADDTOFUNCFUNCDEFS =/ "C"
ADDTOFUNCFUNCDEFS =/ "H"
ADDTOFUNCFUNCDEFS =/ "D"

CMD_ADDTOMENU = "AddToMenu" MENUNAME [ADDTOMENULABEL RESTOFLINE_COMMAND]

CMD_ALL = "All" [ALLOPTIONS] ["(" ALLCONDITION ")"] RESTOFLINE_COMMAND
ALLOPTIONS = "Reverse"
ALLOPTIONS =/ "UseStack"

CMD_CLASS_CIRCULATE = ("Any" / "Current" / "Next" / "None" / "Prev")
	["(" CIRCULATECONDITION ")"] RESTOFLINE_COMMAND
CIRCULATECONDITION = (WINDOWNAMEPATTERN / ["!"] CIRCULATEKEYWORD)
	*("," ["!"] CIRCULATEKEYWORD)
WINDOWNAMEPATTERN = TOKEN
CIRCULATEKEYWORD = !!!

CMD_ANIMATEDMOVE = "AnimatedMove" ANIMATEMOVEARGS ANIMATEMOVEARGS
	[ANIMATEDMOVEKEYWORD]
ANIMATEMOVEARGS = !!!
ANIMATEDMOVEKEYWORD = "Warp"

CMD_ASTERISK = "Asterisk" [MODULE_LINE]

CMD_BEEP = "Beep"

CMD_BORDERSTYLE = "BorderStyle" BORDERSTYLESTATE
	[BORDERSTYLESTYLE] [BORDERSTYLEFLAG]
BORDERSTYLESTATE = "Active" / "Inactive"
BORDERSTYLESTYLE = "TiledPixmap" / "Colorset"
BORDERSTYLEFLAG = ["!"] BORDERSTYLEKEYWORD ("," ["!"] BORDERSTYLEKEYWORD)
BORDERSTYLEKEYWORD = "HiddenHandles"
BORDERSTYLEKEYWORD =/ "NoInset"
BORDERSTYLEKEYWORD =/ "Raised"
BORDERSTYLEKEYWORD =/ "Sunk"
BORDERSTYLEKEYWORD =/ "Flat"
BORDERSTYLEKEYWORD =/ "Simple"

CMD_BREAK = "Break" [BREAKLEVELS]
BREAKLEVELS = INT

CMD_BUGOPTS = "BugOpts" BUGOPTSOPTION
BUGOPTSOPTION = 1*(BUGOPTSKEYWORD [BOOL_OR_TOGGLE])
BUGOPTSKEYWORD = "FlickingMoveWorkaround"
BUGOPTSKEYWORD =/ "MixedVisualWorkaround"
BUGOPTSKEYWORD =/ "ModalityIsEvil"
BUGOPTSKEYWORD =/ "RaiseOverNativeWindows"
BUGOPTSKEYWORD =/ "RaiseOverUnmanaged"
BUGOPTSKEYWORD =/ "FlickingQtDialogsWorkaround"
BUGOPTSKEYWORD =/ "QtDragnDropWorkaround"
BUGOPTSKEYWORD =/ "EWMHIconicStateWorkaround"
BUGOPTSKEYWORD =/ "DisplayNewWindowNames"
BUGOPTSKEYWORD =/ "ExplainWindowPlacement"
BUGOPTSKEYWORD =/ "DebugCRMotionMethod"
BUGOPTSKEYWORD =/ "TransliterateUtf8"

CMD_BUSYCURSOR = "BusyCursor" BUSYCURSOROPTION *("," BUSYCURSOROPTION)
BUSYCURSOROPTION = 1*(BUSYCURSORKEYWORD BOOL)
BUSYCURSORKEYWORD = "DynamicMenu"
BUSYCURSORKEYWORD =/ "ModuleSynchronous"
BUSYCURSORKEYWORD =/ "Read"
BUSYCURSORKEYWORD =/ "Wait"
BUSYCURSORKEYWORD =/ "*"

CMD_BUTTONSTATE = "ButtonState" BUTTONSTATEOPTION *("," BUTTONSTATEOPTION)
BUTTONSTATEOPTION = BUTTONSTATEKEYWORD [BOOL]
BUTTONSTATEKEYWORD = "ActiveUp"
BUTTONSTATEKEYWORD =/ "ActiveDown"
BUTTONSTATEKEYWORD =/ "InactiveUp"
BUTTONSTATEKEYWORD =/ "InactiveDown"

CMD_BUTTONSTYLE = "ButtonStyle" BUTTONSTYLEBUTTON
	[BUTTONSTYLESTATE] [BUTTONSTYLESTYLE] [FLAGS]
BUTTONSTYLEBUTTON = 0-9
BUTTONSTYLEBUTTON =/ "All"
BUTTONSTYLEBUTTON =/ "Left"
BUTTONSTYLEBUTTON =/ "Right"
BUTTONSTYLEBUTTON =/ "Reset"
BUTTONSTYLEBUTTONSTATE = "ActiveUp"
BUTTONSTYLEBUTTONSTATE =/ "ActiveDown"
BUTTONSTYLEBUTTONSTATE =/ "InactiveUp"
BUTTONSTYLEBUTTONSTATE =/ "InactiveDown"
BUTTONSTYLEBUTTONSTATE =/ BUTTONSTYLEACTIVE
BUTTONSTYLEBUTTONSTATE =/ "Inactive"
BUTTONSTYLEBUTTONSTATE =/ TOGGLE
BUTTONSTYLEBUTTONSTATE =/ "AllActive"
BUTTONSTYLEBUTTONSTATE =/ "AllInactive"
BUTTONSTYLEBUTTONSTATE =/ "AllNormal"
BUTTONSTYLEBUTTONSTATE =/ "AllToggled"
BUTTONSTYLEBUTTONSTATE =/ "AllUp"
BUTTONSTYLEBUTTONSTATE =/ "AllDown"
BUTTONSTYLEBUTTONSTATE =/ "AllActiveUp"
BUTTONSTYLEBUTTONSTATE =/ "AllActiveDown"
BUTTONSTYLEBUTTONSTATE =/ "AllInactiveUp"
BUTTONSTYLEBUTTONSTATE =/ "AllInactiveDown"
BUTTONSTYLEACTIVE = "Active" ; - implies FOCUSED_WINDOW
BUTTONSTYLESTYLE = "Simple"
BUTTONSTYLESTYLE =/ "Default"
BUTTONSTYLESTYLE =/ "Solid"
BUTTONSTYLESTYLE =/ "Colorset"
BUTTONSTYLESTYLE =/ "Vector"
BUTTONSTYLESTYLE =/ BUTTONSTYLEGRADIENT
BUTTONSTYLESTYLE =/ "Pixmap"
BUTTONSTYLESTYLE =/ AdjustedPixmap"
BUTTONSTYLESTYLE =/ "ShrunkPixmap"
BUTTONSTYLESTYLE =/ "StretchedPixmap"
BUTTONSTYLESTYLE =/ "TiledPixmap"
BUTTONSTYLESTYLE =/ "MiniIcon"
BUTTONSTYLEGRADIENT = TYPE START-COLOUR END-COLOUR
BUTTONSTYLESTYLEFLAG =
	["!"] BUTTONSTYLESTYLEKEYWORD *("," ["!"] BUTTONSTYLESTYLEKEYWORD)
BUTTONSTYLESTYLEKEYWORD = "Raised"
BUTTONSTYLESTYLEKEYWORD =/ "Sunk"
BUTTONSTYLESTYLEKEYWORD =/ "Flat"
BUTTONSTYLESTYLEKEYWORD =/ "UseBorderStyle"
BUTTONSTYLESTYLEKEYWORD =/ "UseTitleStyle"
; (XXX = "Raised, Sunk, and Flat" can only be used initially!!!")

CMD_CHANGEDECOR = "ChangeDecor" [DECORNAME]

CMD_CHANGEMENUSTYLE = "ChangeMenuStyle" MENUSTYLENAME MENUNAME

CMD_CLEANUPCOLORSETS = "CleanupColorsets"

CMD_CLICKTIME = "ClickTime" POSINT
; (stores the negative value during startup>

CMD_CMD_CLASS_CLOSE = "Close" / "Delete" / "Destroy"
; work on context window

CMD_COLORLIMIT = "ColorLimit"
; obsolete, has been removed

CMD_COLORMAPFOCUS = "ColormapFocus" ("FollowsMouse" / "FollowsFocus")

CMD_COLORSET = "Colorset" COLORSET_NUM COLORSETOPTION *("," COLORSETOPTION)
COLORSETOPTION = COLORSETKEYWORD [COLORSETVALUE]
COLORSETKEYWORD = "fg"
COLORSETKEYWORD =/ "Fore"
COLORSETKEYWORD =/ "Foreground"
COLORSETKEYWORD =/ "bg"
COLORSETKEYWORD =/ "Back"
COLORSETKEYWORD =/ "Background"
COLORSETKEYWORD =/ "hi"
COLORSETKEYWORD =/ "Hilite"
COLORSETKEYWORD =/ "Hilight
COLORSETKEYWORD =/ "sh"
COLORSETKEYWORD =/ "Shade"
COLORSETKEYWORD =/ "Shadow"
COLORSETKEYWORD =/ "fgsh"
COLORSETKEYWORD =/ "Pixmap"
COLORSETKEYWORD =/ "TiledPixmap"
COLORSETKEYWORD =/ "AspectPixmap"
COLORSETKEYWORD =/ "Transparent"
COLORSETKEYWORD =/ "RootTransparent"
COLORSETKEYWORD =/ "Shape"
COLORSETKEYWORD =/ "TiledShape"
COLORSETKEYWORD =/ "AspectShape"
COLORSETKEYWORD =/ "NoShape"
COLORSETKEYWORD =/ ("V" / "B" / "D" / "S" / "C" / "R" / "Y") "Gradient"
COLORSETKEYWORD =/ "Tint"
COLORSETKEYWORD =/ "fgTint"
COLORSETKEYWORD =/ "bgTint"
COLORSETKEYWORD =/ "Alpha"
COLORSETKEYWORD =/ "fgAlpha"
COLORSETKEYWORD =/ "Dither"
COLORSETKEYWORD =/ "NoDither"
COLORSETKEYWORD =/ "IconTint"
COLORSETKEYWORD =/ "IconAlpha"
COLORSETKEYWORD =/ "Plain"
COLORSETVALUE = INT
COLORSETVALUE =/ COLORNAME
COLORSETVALUE =/ IMAGEFILENAME
COLORSETVALUE =/ INTPERCENTAGE
; (memory usage depends on highest colorset number)

COPYMENUSTYLE = "CopyMenuStyle" MENUSTYLENAME MENUSTYLENAME

CMD_CURSORMOVE = "CursorMove"
	CURSORMOVEDIM[CURSORMOVESUFFIX] CURSORMOVEDIM[CURSORMOVESUFFIX]
CURSORMOVEDIM = INT
CURSORMOVESUFFIX = "p"

CMD_CURSORSTYLE = "CursorStyle" CURSORSTYLECONTEXT [CURSORSTYLEOPTION]
CURSORSTYLECONTEXT = KEYWORD / X11NAME
CURSORSTYLEKEYWORD = "POSITION"
CURSORSTYLEKEYWORD =/ "TITLE"
CURSORSTYLEKEYWORD =/ "DEFAULT"
CURSORSTYLEKEYWORD =/ "SYS"
CURSORSTYLEKEYWORD =/ "MOVE"
CURSORSTYLEKEYWORD =/ "RESIZE"
CURSORSTYLEKEYWORD =/ "WAIT"
CURSORSTYLEKEYWORD =/ "MENU"
CURSORSTYLEKEYWORD =/ "SELECT"
CURSORSTYLEKEYWORD =/ "DESTROY"
CURSORSTYLEKEYWORD =/ "TOP"
CURSORSTYLEKEYWORD =/ "RIGHT"
CURSORSTYLEKEYWORD =/ "BOTTOM"
CURSORSTYLEKEYWORD =/ "LEFT"
CURSORSTYLEKEYWORD =/ "TOP_LEFT"
CURSORSTYLEKEYWORD =/ "TOP_RIGHT"
CURSORSTYLEKEYWORD =/ "BOTTOM_LEFT"
CURSORSTYLEKEYWORD =/ "BOTTOM_RIGHT"
CURSORSTYLEKEYWORD =/ "TOP_EDGE"
CURSORSTYLEKEYWORD =/ "RIGHT_EDGE"
CURSORSTYLEKEYWORD =/ "BOTTOM_EDGE"
CURSORSTYLEKEYWORD =/ "LEFT_EDGE"
CURSORSTYLEKEYWORD =/ "ROOT"
CURSORSTYLEKEYWORD =/ "STROKE"
CURSORSTYLEKEYWORD =/ "None"
CURSORSTYLEKEYWORD =/ "Tiny"
CURSORSTYLEX11NAME = "top_left_corner"
CURSORSTYLEX11NAME =/ "top_left_arrow"
CURSORSTYLEX11NAME =/ "hand2"
CURSORSTYLEX11NAME =/ "fleur"
CURSORSTYLEX11NAME =/ "sizing"
CURSORSTYLEX11NAME =/ "watch"
CURSORSTYLEX11NAME =/ "crosshair"
CURSORSTYLEX11NAME =/ "pirate"
CURSORSTYLEX11NAME =/ "top_side"
CURSORSTYLEX11NAME =/ "bottom_side"
CURSORSTYLEX11NAME =/ "left_side"
CURSORSTYLEX11NAME =/ "top_right_corner"
CURSORSTYLEX11NAME =/ "bottom_left_corner"
CURSORSTYLEX11NAME =/ "top_side"
CURSORSTYLEX11NAME =/ "right_side"
CURSORSTYLEX11NAME =/ "left_side"
CURSORSTYLEX11NAME =/ "left_ptr"
CURSORSTYLEX11NAME =/ "plus"
CURSORSTYLEXOPTION = IMAGEFILE [INT]
CURSORSTYLEXOPTION =/ "fg"
CURSORSTYLEXOPTION =/ "bg"

CMD_DEFAULTCOLORS = "DefaultColors" [COLOUR_FG] [COLOUR_BG]
<These need defining!>

CMD_DEFAULTCOLORSET = "DefaultColorset" (COLORSET_NUM/ "-1")

CMD_DEFAULTFONT = "DefaultFont" [FONTNAME]

CMD_DEFAULTICON = "DefaultIcon" [IMAGEFILE]

CMD_DEFAULTLAYERS = "DefaultLayers" INT INT INT

CMD_DESCHEDULE = "Deschedule" [INT]

CMD_DESK = "Desk" [!!!]
; OBSOLETED BY GOTODESK

CMD_DESKTOPNAME = "DesktopName" INT DESKTOPNAME
DESKTOPNAME = TOKEN

CMD_DESKTOPSIZE = "DesktopSize" DESKTOPSIZDIM "x" DESKTOPSIZDIM
DESKTOPSIZEDIM = INT

CMD_DESTROYDECOR = "DestroyDecor" [DESTROYDECORRECREATE] DECORNAME
DESTROYDECORRECREATE = "recreate"

CMD_DESTROYFUNC = "DestroyFunc" [FUNCNAME]

CMD_DESTROYMENU = "DestroyMenu" ["recreate"] MENUNAME

CMD_DESTROYMENUSTYLE = "DestroyMenuStyle" MENUSTYLENAME

CMD_DESTROYMODULECONFIG = "DestroyModuleConfig" MODULECONFIG

CMD_DESTROYSTYLE = "DestroyStyle" STYLENAME

CMD_DESTROYWINDOWSTYLE = "DestroyWindowStyle"
; operates on context window

CMD_DIRECTION = "Direction" [DIRECTIONFROMPOINTER] DIRS_CENTER
	["(" SELECTCMDCONDITION ")"] RESTOFLINE_COMMAND
DIRECTIONFROMPOINTER = "FromPointer"

CMD_ECHO = "Echo" RESTOFLINE

CMD_ECHOFUNCDEFINITION = "EchoFuncDefinition" FUNCNAME

CMD_EDGECOMMAND = "EdgeCommand" [DIRS_MAIN [RESTOFLINE_COMMAND]]

CMD_EDGELEAVECOMMAND = "EdgeLeaveCommand" [DIRS_MAIN [RESTOFLINE_COMMAND]]

CMD_EDGERESISTANCE = "EdgeResistance"
; OBSOLETED BY CORRESPONDING STYLE COMMAND

CMD_EDGESCROLL = "EdgeScroll" EDGESCROLLDIM[EDGESCROLLSUFFIX]
	EDGESCROLLDIM[EDGESCROLLSUFFIX] [EDGESCROLLOPTION]
EDGESCROLLDIM = INT
EDGESCROLLSUFFIX = "p"
EDGESCROLLOPTION = "Wrap"
EDGESCROLLOPTION =/ "WrapX"
EDGESCROLLOPTION =/ "WrapY"

CMD_EDGETHICKNESS = "EdgeThickness" EDGETHICKNESSVAL
EDGETHICKNESSVAL = "0" / "1" / "2"

CMD_EMULATE = "Emulate" EMULATEVAL
EMULATEVAL = "Mvwm"
EMULATEVAL =/ "Mwm"
EMULATEVAL =/ "Win"

CMD_ESCAPEFUNC = "EscapeFunc"

CMD_EWMHBASESTRUTS = "EwmhBaseStruts" INT INT INT INT

CMD_EWMHNUMBEROFDESKTOPS = "EwmhNumberOfDesktops" INT INT

CMD_EXEC = "Exec" RESTOFLINE_COMMAND

CMD_EXECUSESHELL = "ExecUseShell" EXECUSESHELLSHELL
EXECUSESHELLSHELL = !!!

CMD_FAKECLICK = "FakeClick" FAKECLICKACTION *("," FAKECLICKACTION)
FAKECLICKACTION = FAKECLICKCOMMAND FAKECLICKVALUE
FAKECLICKCOMMAND = (FAKECLICKKEYWORD, FAKECLICKVALUE)
FAKECLICKKEYWORD = "press"
FAKECLICKKEYWORD =/ "release"
FAKECLICKKEYWORD =/ "modifiers"
FAKECLICKKEYWORD =/ "wait"
FAKECLICKKEYWORD =/ FAKECLICKDEPTH
FAKECLICKVALUE = "1"
FAKECLICKVALUE =/ "2"
FAKECLICKVALUE =/ "3"
FAKECLICKVALUE =/ "4"
FAKECLICKVALUE =/ "5"
FAKECLICKVALUE =/ "Mod1"
FAKECLICKVALUE =/ "Mod2"
FAKECLICKVALUE =/ "Mod3"
FAKECLICKVALUE =/ "Mod4"
FAKECLICKVALUE =/ "Mod5"
FAKECLICKVALUE =/ "6"
FAKECLICKVALUE =/ "7"
FAKECLICKVALUE =/ "8"
FAKECLICKVALUE =/ "Shift"
FAKECLICKVALUE =/ "Lock"
FAKECLICKVALUE =/ "Control"
FAKECLICKDEPTH = "depth"
FAKECLICKDEPTH =/ "0"
FAKECLICKDEPTH =/ "1"
FAKECLICKDEPTH =/ "2"
FAKECLICKDEPTH =/ "3"
FAKECLICKDEPTH =/ INT

CMD_FAKEKEYPRESS = "FakeKeypress" FAKEKEYPRESSACTION *("," FAKEKEYPRESSACTION)
FAKEKEYPRESSACTION = FAKEKEYPRESSCOMMAND FAKEKEYPRESSVALUE
FAKEKEYPRESSKEYWORD = "press"
FAKEKEYPRESSKEYWORD =/ "release"
FAKEKEYPRESSKEYWORD =/ "modifiers"
FAKEKEYPRESSKEYWORD =/ "wait"
FAKEKEYPRESSKEYWORD =/ DEPTH
FAKEKEYPRESSVALUE = KEYNAME
FAKEKEYPRESSDEPTH = "depth"
FAKEKEYPRESSDEPTH =/ "0"
FAKEKEYPRESSDEPTH =/ "1"
FAKEKEYPRESSDEPTH =/ "2"
FAKEKEYPRESSDEPTH =/ "3"
FAKEKEYPRESSDEPTH =/ INT

CMD_FLIPFOCUS = "FlipFocus" ["nowarp"]

CMD_FOCUS = "Focus" ["nowarp"]

CMD_FOCUSSTYLE = "FocusStyle" STYLEOPTIONS

CMD_FUNCTION = "Function" [FUNCNAME]

CMD_GLOBALOPTS = "GlobalOpts"
; OBSOLETE ignoring!

CMD_GNOMEBUTTON = "GnomeButton"
; REMOVED IN MVWM ALREADY ignoring!

CMD_GNOMESHOWDESKS = "GnomeShowDesks"
; REMOVED IN MVWM ALREADY ignoring!

CMD_GOTODESK = "GotoDesk" DESKNUMBER
DESKNUMBER = ["prev" / (INT [INT [INT [INT]]])]

CMD_GOTODESKANDPAGE = "GotoDeskAndPage" "prev" / (INT INT INT)

CMD_GOTOPAGE = "GotoPage" PAGE_ARGUMENTS
PAGE_ARGUMENTS = ["prev" / ([OPTIONS] 2(PAGECCORD[PAGESUFFIX])
OPTIONS = ["!"] ("wrapx" / "wrapy" / "nodesklimitx" / "nodesklimity")
PAGECOORD = INT
PAGESUFFIX = "p"

CMD_HIDEGEOMETRYWINDOW = "HideGeometryWindow" [HIDEGEOMETRYWINDOWCOMMAND]
HIDEGEOMETRYWINDOWCOMMAND = "Never"
HIDEGEOMETRYWINDOWCOMMAND =/ "Move"
HIDEGEOMETRYWINDOWCOMMAND =/ "Resize"

CMD_HILIGHTCOLOR = "HilightColor"
; OBSOLETE ignoring

CMD_HILIGHTCOLORSET = "HilightColorset" [COLORSET_NUM]

CMD_ICONFONT = "IconFont" FONTNAME
; OBSOLETE ignoring

CMD_ICONPATH = "IconPath"
; OBSOLETE ignoring

CMD_ICONIFY = "Iconify" BOOL_OR_TOGGLE

CMD_IGNOREMODIFIERS = "IgnoreModifiers" [ BINDINGMODIFIERS ]

CMD_IMAGEPATH = "ImagePath" [PATH]

CMD_INFOSTOREADD = "InfoStoreAdd" INFOSTOREKEY INFOSTOREVALUE
INFOSTOREKEY = STRING
INFOSTOREVALUE = STRING

CMD_INFOSTOREREMOVE = "InfoStoreRemove" [INFOSTOREREKEY]

CMD_KEEPRC = "KeepRc" [RESTOFLINE_COMMAND]

CMD_CLASS_KEY = ("Key" / "PointerKey") ["(" WINDOWSELECTOR ")"] KEYNAME
	BINDINGCONTEXT BINDINGMODIFIERS RESTOFLINE_COMMAND

CMD_KILLMODULE = "KillModule" [MODULENAME] [MODULEALIAS]

CMD_LAYER = "Layer" [INT INT] / "default"

CMD_LOCALEPATH = "LocalePath" [PATH]

CMD_CLASS_RAISELOWER = ("Lower" / "Raise" / "RaiseLower")
; operates on context window

CMD_MAXIMIZE = "Maximize" [MAXIMIZEFLAGS] [BOOL_OR_TOGGLE / "forget"]
	[[MAXIMIZEDIM[MAXIMIZESUFFIX]] MAXIMIZEDIM[MAXIMIZESUFFIX]]
MAXIMIZEGROWOPTS = "grow"
MAXIMIZEGROWOPTS =/ "growleft"
MAXIMIZEGROWOPTS =/ "growright"
MAXIMIZEGROWOPTS =/ "growup"
MAXIMIZEGROWOPTS =/ "growdown"
MAXIMIZEDIM = INT
MAXIMIZEDIM =/ MAXIMIZEGROWOPTS
MAXIMIZESUFFIX = "p"
MAXIMIZEFLAGS = "ewmhiwa"
MAXIMIZEFLAGS =/ "growonwindowlayer"
MAXIMIZEFLAGS =/ "growonlayers"
MAXIMIZEFLAGS =/ ("screen" / XINERAMASCR)

CMD_CLASS_MENU = ("Menu" / "Popup") MENUNAME [MENUPOSITION] [MENUCOMMAND]
MENUPOSITION = MENUCONTEXT_RECTANGLE INT INT [MENUOPTIONS]
MENUCONTEXT_RECTANGLE = "Root" !!!
MENUCONTEXT =/ "XineramaRoot"
MENUCONTEXT =/ "Mouse"
MENUCONTEXT =/ "Window" /
	"Interior"
	"Interior =/ "Title"
	"Interior =/ ("Button" INT) "Icon"
	"Interior =/ "Item"
	"Interior =/ "Context"
	"Interior =/ "This"
	"Interior =/ ("Rectangle" MENUCONTEXTGEOMETRY)
MENUOPTIONS = "TearoffImmediately"
MENUOPTIONS =/ "SelectInPlace"
MENUOPTIONS = !!!
MENUCONTEXTGEOMETRY = !!!

CMD_MENUSTYLE = "MenuStyle" MENUSTYLENAME *(["!"] MENUSTYLEOPTIONS)
MENUSTYLEOPTIONS = "Mvwm"
MENUSTYLEOPTIONS =/ "Mwm"
MENUSTYLEOPTIONS =/ "Win"
MENUSTYLEOPTIONS =/ "BorderWidth"
MENUSTYLEOPTIONS =/ "Foreground"
MENUSTYLEOPTIONS =/ "Background"
MENUSTYLEOPTIONS =/ "Greyed"
MENUSTYLEOPTIONS =/ "HilightBack"
MENUSTYLEOPTIONS =/ "HilightTitleBack"
MENUSTYLEOPTIONS =/ "ActiveFore"
MENUSTYLEOPTIONS =/ "MenuColorset"
MENUSTYLEOPTIONS =/ "ActiveColorset"
MENUSTYLEOPTIONS =/ "GreyedColorset"
MENUSTYLEOPTIONS =/ "TitleColorset"
MENUSTYLEOPTIONS =/ "Hilight3DThick"
MENUSTYLEOPTIONS =/ "Hilight3DThin"
MENUSTYLEOPTIONS =/ "Hilight3DOff"
MENUSTYLEOPTIONS =/ "Hilight3DThickness"
MENUSTYLEOPTIONS =/ "Animation"
MENUSTYLEOPTIONS =/ "Font"
MENUSTYLEOPTIONS =/ "TitleFont"
MENUSTYLEOPTIONS =/ "MenuFace"
MENUSTYLEOPTIONS =/ "PopupDelay"
MENUSTYLEOPTIONS =/ "PopupOffset"
MENUSTYLEOPTIONS =/ "TitleWarp"
MENUSTYLEOPTIONS =/ "TitleUnderlines0"
MENUSTYLEOPTIONS =/ "TitleUnderlines1"
MENUSTYLEOPTIONS =/ "TitleUnderlines2"
MENUSTYLEOPTIONS =/ "SeparatorsLong"
MENUSTYLEOPTIONS =/ "SeparatorsShort"
MENUSTYLEOPTIONS =/ "TrianglesSolid"
MENUSTYLEOPTIONS =/ "TrianglesRelief"
MENUSTYLEOPTIONS =/ "PopupImmediately"
MENUSTYLEOPTIONS =/ "PopupDelayed"
MENUSTYLEOPTIONS =/ "PopdownImmediately"
MENUSTYLEOPTIONS =/ "PopdownDelayed"
MENUSTYLEOPTIONS =/ "PopupActiveArea"
MENUSTYLEOPTIONS =/ "DoubleClickTime"
MENUSTYLEOPTIONS =/ "SidePic"
MENUSTYLEOPTIONS =/ "SideColor"
MENUSTYLEOPTIONS =/ "PopupAsRootMenu"
MENUSTYLEOPTIONS =/ "PopupAsSubmenu"
MENUSTYLEOPTIONS =/ "PopupIgnore"
MENUSTYLEOPTIONS =/ "PopupClose"
MENUSTYLEOPTIONS =/ "RemoveSubmenus"
MENUSTYLEOPTIONS =/ "HoldSubmenus"
MENUSTYLEOPTIONS =/ "SubmenusRight"
MENUSTYLEOPTIONS =/ "SubmenusLeft"
MENUSTYLEOPTIONS =/ "SelectOnRelease"
MENUSTYLEOPTIONS =/ "ItemFormat"
MENUSTYLEOPTIONS =/ "VerticalItemSpacing"
MENUSTYLEOPTIONS =/ "VerticalMargins"
MENUSTYLEOPTIONS =/ "VerticalTitleSpacing"
MENUSTYLEOPTIONS =/ "AutomaticHotkeys"
MENUSTYLEOPTIONS =/ "UniqueHotkeyActivatesImmediate"
MENUSTYLEOPTIONS =/ "MouseWheel"
MENUSTYLEOPTIONS =/ "ScrollOffPage"
MENUSTYLEOPTIONS =/ "TrianglesUseFore"
; add option syntax

CMD_CLASS_MODULE = ("Module" / "ModuleListenOnly") CMDMODULEARGS
CMDMODULEARGS = MODULENAME [MODULEALIAS]

CMD_MODULEPATH = "ModulePath" PATH

CMD_MODULESYNCHRONOUS = "ModuleSynchronous" ["Expect" STRING] ["Timeout" INT]
	CMDMODULEARGS

CMD_MODULETIMEOUT = "ModuleTimeout" INT

CMD_MOUSE = "Mouse" ["(" WINDOWSELECTOR ")"] BUTTON
	BINDINGCONTEXT BINDINGMODIFIERS COMMAND

CMD_MOVE = "Move" [MOVEARGS]
MOVEARGS = !!!

CMD_MOVETHRESHOLD = "MoveThreshold" [INT]

CMD_MOVETODESK = "MoveToDesk" DESKNUMBER

CMD_MOVETOPAGE = "MoveToPage" ["prev"] [MOVETOPAGEOPTIONS]
	2(MOVETOPAGECOORD[MOVETOPAGESUFFIX])
MOVETOPAGEOPTIONS = "wrapx" / "wrapy" / "nodesklimitx" / "nodesklimity"
MOVETOPAGECOORD = INT
MOVETOPAGESUFFIX = "p" / "w"

CMD_MOVETOSCREEN = "MoveToScreen" [XRANDRMONITORNAME]
XRANDRMONITORNAME = !!!

CMD_NOWINDOW = "NoWindow" RESTOFLINE_COMMAND

CMD_NOP = "Nop"

CMD_OPAQUEMOVESIZE = "OpaqueMoveSize" [INT]

CMD_CLASS_PICK = ("ThisWindow" / "Pick" / "PointerWIndow" )
	["(" SELECTCMDCONDITION ")"] RESTOFLINE_COMMAND

CMD_PIPEREAD = "PipeRead" TOKEN ["quiet"]

CMD_PIXMAPPATH = "PixmapPath"
; OBSOLETE ignoring

CMD_PLACEAGAIN = "PlaceAgain" *("Anim" "Icon")

CMD_PLUS = "Plus" RESTOFLINE

CMD_PRINTINFO = "PrintInfo" PRINTINFOSUBJECT
PRINTINFOSUBJECT = (PRINTINFOKEYWORD [PRINTINFOVAL])
PRINTINFOVAL = "0"
PRINTINFOVAL =/ "1"
PRINTINFOVAL =/ "2"
PRINTINFOKEYWORD = "Colors"
PRINTINFOKEYWORD =/ "ImageCache"
PRINTINFOKEYWORD =/ "Locale"
PRINTINFOKEYWORD =/ "NLS"
PRINTINFOKEYWORD =/ "Style"
PRINTINFOKEYWORD =/ "Bindings"
PRINTINFOKEYWORD =/ "Infostore"

CMD_QUIT = "Quit"

CMD_QUITSCREEN = "QuitScreen"

CMD_QUITSESSION = "QuitSession"
; OBSOLETE ignoring

CMD_READ = "Read" FILENAME ["quiet"]

CMD_CLASS_RECAPTURE = ("Recapture" / "RecaptureWindow")

CMD_CLASS_REFRESH = ("Refresh" / "RefreshWindow")

CMD_REPEAT = "Repeat" ["command"]

CMD_CLASS_RESIZE = ("Resize" / "ResizeMaximize") [RESIZEOPTS]
RESIZEOPTS = (RESIZEOPTS_BR / RESIZEOPTS_OTHER) [2RESIZEARG]
RESIZEOPTS_BR = ("bottomright" / "br") MOVEARGS
RESIZEOPTS_OTHER =
	("frame" / "fixeddirection" /
	("direction" (DIRS_CENTER / "automatic")) /
	("warptoborder" ["automatic"]))
RESIZEARG = "keep" / (RESIZEARG_2 [RESIZEARGSUFFIX])
RESIZEARG_2 = "w" / (["w"] RESIZEARGVAL)
RESIZEARGVAL = (SIGN INT) / POSINT
RESIZEARGSUFFIX = "p" / "c"

CMD_CLASS_RESIZEMOVE = ("ResizeMove" / "ResizeMoveMaximize")
	RESIZEOPTS MOVEARGS

CMD_RESTACKTRANSIENTS = "RestackTransients"

CMD_RESTART = "Restart" [STRING]

CMD_SAVEQUITSESSION = "SaveQuitSession"
; OBSOLETE ignoring

CMD_SAVESESSION = "SaveSession"
; OBSOLETE ignoring

CMD_SCANFORWINDOW = "ScanForWindow" ["FromPointer"] DIRS_MAIN DIRS_MAIN
	["(" SELECTCMDCONDITION ")"] RESTOFLINE_COMMAND

CMD_SCHEDULE = "Schedule" ["periodic"] INT [INT] RESTOFLINE_COMMAND

CMD_SCROLL = "Scroll"
	[(SCROLLDIM[SCROLLSUFFIX] SCROLLDIM[SCROLLSUFFIX]) / OPTION]
SCROLLDIM = INT
OPTION = "reverse"
SCROLLSUFFIX = "p"

CMD_SENDTOMODULE = "SendToModule" [MODULENAME] [STRING]

CMD_SETANIMATION = "SetAnimation" INT [INT]

CMD_SETENV = "SetEnv" [STRING] [STRING]

CMD_SILENT = "Silent" RESTOFLINE_COMMAND

CMD_SNAPATTRACTION = "SnapAttraction"
; OBSOLETE style option ignoring

CMD_SNAPGRID = "SnapGrid"
; OBSOLETE style option ignoring

CMD_STATE = "State" STATENUM [BOOL]

CMD_CLASS_STICK = ("Stick" / "StickAcrossDesks" / "StickAcrossPages")
	[BOOL_OR_TOGGLE]

CMD_STROKE = "Stroke"
; OBSOLETE removed in mvwm

CMD_STROKEFUNC = "StrokeFunc"
; OBSOLETE removed in mvwm

CMD_CLASS_STYLE = ("Style" / "WindowStyle") [STYLENAME] [STYLEOPTIONS]
; note: WindowStyle operates on context window
STYLEOPTIONS = STYLEOPTION ("," STYLEOPTION)
STYLEOPTION = !!!

CMD_TEARMENUOFF = "TearMenuOff"
; Applies to menu context only

CMD_TEST = "Test" ["(" ["!"] TESTCONDITION ")"] RESTOFLINE_COMMAND
TESTCONDITION = (TESTKEYWORD [TESTVALUE])
TESTKEYWORD = ("version" TESTOPERATOR DOTTEDNUM) / ("EnvIsSet" STRING) /
	("EnvMatch" STRING) / ("EdgeHasPointer" DIRS_MAIN) /
	("EdgeIsActive" DIRS_MAIN) / "Start" / "Init" / "Restart" / "Exit" /
	"Quit" / "ToRestart" / "True" / "False" / "F" / "R" / "W" / "X" / "I"
TESTOPERATOR = ">=" / ">" / "<=" / "==" / "!="
TESTVALUE = !!!
DOTTEDNUM = !!!

CMD_TESTRC = "TestRc" ["(" ["!"]TESTRCRC ")"] RESTOFLINE_COMMAND
TESTRCRC = "0" / "1" / "-1" / "-2" / "NoMatch" / "Match" / "Error" / "Break"

CMD_TITLE = "Title"
; Applies to menu context only

CMD_TITLESTYLE = "TitleStyle"
!!!

CMD_UNSETENV = "UnsetEnv" [STRING]

CMD_UPDATEDECOR = "UpdateDecor" [DECORNAME]

CMD_UPDATESTYLES = "UpdateStyles"

CMD_WAIT = "Wait" [TOKEN]

CMD_WARPTOWINDOW = "WarpToWindow" [PERCENT_ARG_PAIR]
; note: arguments not used when used on an unmanaged window
; note: arguments are ignored if not valid
; note: ignores rest of line
; note: syntax description complete

CMD_WINDOWID = "WindowId"
	[("root" [WINDOWIDSCREENNUM]) / (WINDOWID [CONDITIONMASK])]
; note: ignores rest of line
; note: syntax description complete
WINDOWIDSCREENNUM = POSINT
; note: valid range is 0 to <number of screens - 1>
WINDOWID = LONGINT
; note: long value parsed by strtol without error checking

CMD_WINDOWLIST = "WindowList" ["(" WINDOWLISTCONDITIONS ")"]
	[WINDOWLISTPOSITION] [WINDOWLLISTOPTIONS] [COMMAND]
WINDOWLISTPOSITION = WINDOWLISTCONTEXT_RECTANGLE INT INT
	[WINDOWLISTCONTEXTOPTIONS]
WINDOWLISTCONTEXT_RECTANGLE = "Root"
WINDOWLISTCONTEXT_RECTANGLE =/ "XineramaRoot"
WINDOWLISTCONTEXT_RECTANGLE =/ "Mouse"
WINDOWLISTCONTEXT_RECTANGLE =/ "Window"
WINDOWLISTCONTEXT_RECTANGLE =/ "Interior"
WINDOWLISTCONTEXT_RECTANGLE =/ "Tiitle"
WINDOWLISTCONTEXT_RECTANGLE =/ ("Button" INT)
WINDOWLISTCONTEXT_RECTANGLE =/ "Icon"
WINDOWLISTCONTEXT_RECTANGLE =/ "Item"
WINDOWLISTCONTEXT_RECTANGLE =/ "Context"
WINDOWLISTCONTEXT_RECTANGLE =/ "This"
WINDOWLISTCONTEXT_RECTANGLE =/ ("Rectangle" GEOMETRY)
WINDOWLISTCONTEXTOPTIONS = "TearoffImmediately"
WINDOWLISTCONTEXTOPTIONS =/ "SelectInPlace"
WINDOWLISTOPTIONS = (WINDOWLISTKEYWORD [WINDOWLISTVALUE])
WINDOWLISTOPTIONS = "Geometry"
WINDOWLISTOPTIONS =/ "NoGeometry"
WINDOWLISTOPTIONS =/ "NoGeometryWithInfo"
WINDOWLISTOPTIONS =/ "NoDeskNum"
WINDOWLISTOPTIONS =/ "NoLayer"
WINDOWLISTOPTIONS =/ "NoNumInDeskTitle"
WINDOWLISTOPTIONS =/ "NoCurrentDeskTitle"
WINDOWLISTOPTIONS =/ ("MaxLabelWidth" INT)
WINDOWLISTOPTIONS =/ "TitleForAllDesks"
WINDOWLISTOPTIONS =/ ("Function" FUNCNAME)
WINDOWLISTOPTIONS =/ ("Desk" INT)
WINDOWLISTOPTIONS =/ "CurrentDesk"
WINDOWLISTOPTIONS =/ "NoIcons"
WINDOWLISTOPTIONS =/ "Icons"
WINDOWLISTOPTIONS =/ "OnlyIcons"
WINDOWLISTOPTIONS =/ "NoNormal"
WINDOWLISTOPTIONS =/ "Normal"
WINDOWLISTOPTIONS =/ "OnlyNormal"
WINDOWLISTOPTIONS =/ "NoSticky"
WINDOWLISTOPTIONS =/ "Sticky"
WINDOWLISTOPTIONS =/ "OnlySticky"
WINDOWLISTOPTIONS =/ "NoStickyAcrossPages"
WINDOWLISTOPTIONS =/ "StickyAcrossPages"
WINDOWLISTOPTIONS =/ "OnlyStickyAcrossPages"
WINDOWLISTOPTIONS =/ "NoStickyAcrossDesks"
WINDOWLISTOPTIONS =/ "StickyAcrossDesks"
WINDOWLISTOPTIONS =/ "OnlyStickyAcrossDesks"
WINDOWLISTOPTIONS =/ "NoOnTop"
WINDOWLISTOPTIONS =/ "OnTop"
WINDOWLISTOPTIONS =/ "OnlyOnTop"
WINDOWLISTOPTIONS =/ "NoOnBottom"
WINDOWLISTOPTIONS =/ "OnlyOnBottom"
WINDOWLISTOPTIONS =/ (Layer INT [INT])
WINDOWLISTOPTIONS =/ "UseSkipList"
WINDOWLISTOPTIONS =/ "OnlySkipList"
WINDOWLISTOPTIONS =/ "SortByResource"
WINDOWLISTOPTIONS =/ "SortByClass"
WINDOWLISTOPTIONS =/ "NoHotKeys"
WINDOWLISTOPTIONS =/ "SelectOnRelease"
WINDOWLISTOPTIONS =/ "ReverseOrder"
WINDOWLISTOPTIONS =/ "NoDeskSort"
WINDOWLISTOPTIONS =/ "CurrentAtEnd"
WINDOWLISTOPTIONS =/ "IconifiedAtEnd"
WINDOWLISTOPTIONS =/ "UseIconName"
WINDOWLISTOPTIONS =/ "Alphabetic"
WINDOWLISTOPTIONS =/ "NotAlphabetic"
WINDOWLISTKEYWORD = !!!
WINDOWLISTVALUE = !!!
; note: !!! to do

CMD_WINDOWSHADE = "WindowShade" ["shadeagain"]
	["last" / DIRS_MINOR] [WINDOWSHADEMODE]
WINDOWSHADEMODE = WINDOWSHADETOGGLE / WINDOWSHADEON / WINDOWSHADEOFF
WINDOWSHADETOGGLE = () / TOGGLE
WINDOWSHADEON = TRUE
WINDOWSHADEOFF = FALSE / "2"
; note: defaults to toggle
; note: if "last" or DIRS_MINOR is present and valid, ignore the
;       WINDOWSHADEMODE argument if present
; note: ignores rest of line
; note: syntax description complete

CMD_XSYNC = "XSync"
; note: ignores all arguments
; note: syntax description complete

CMD_XSYNCHRONIZE = "XSynchronize" [BOOL_OR_TOGGLE_DEFAULT_TOGGLE]
; note: argument defaults to toggle if missing or invalid
; note: ignores rest of line
; note: syntax description complete

CMD_XORPIXMAP = "XorPixmap" [IMAGEFILE]
; note: if argument is missing, maps to "XorValue 0"
; note: ignores rest of line
; note: syntax description complete

CMD_XORVALUE = "XorValue" [INTEGER_ARGUMENT]
; note: argument defaults to 0 if missing or malformed
; note: argument is converted to unsinged long before use
; note: argument should be parsed as unsigned long to prevent misinterpretation
; note: ignores rest of line
; note: syntax description complete


;; !!! more common rules

; Integer arguments as parsed by GetIntegerArguments()
INTEGER_ARGUMENT = INT

; Loaded by PictureFindImageFile
IMAGEFILE = TOKEN
; note: if file not found, try again with IMAGEFILE ".gz"

; parsed by parse_gravity_argument
DIR_N = "-" / "N" / "North""Top" / "t" / "Up" / "u"
DIR_E =/ "]" / "E" / "East" / "Right" / "r" / "Right" / "r"
DIR_S =/ "_" / "S" / "South" / "Bottom" / "b" / "Down" / "d"
DIR_W =/ "[" / "W" / "West" / "Left" / "l" / "Left" / "l"
DIR_NE =/ "^" / "NE" / "NorthEast" / "TopRight" / "tr" / "UpRight" / "ur"
DIR_SE =/ ">" / "SE" / "SouthEast" / "BottomRight" / "br" / "DownRight" / "dr"
DIR_SW =/ "v" / "SW" / "SouthWest" / "BottomLeft" / "bl" / "DownLeft" / "dl"
DIR_NE =/ "<" / "NW" / "NorthWest" / "TopLeft" / "tl" / "UpLeft" / "ul"
DIR_C = "." / "C" / "Center" / "Centre"
DIRS_MAJOR = DIR_N / DIR_E / DIR_S / DIR_W
DIRS_MINOR = DIRS_MAIN / DIR_NE / DIR_SE / DIR_SW / DIR_NW
DIRS_ALL = DIRS_MAIN / DIRS_DIAG / DIR_C

; Parsed by ParseToggleArgument
BOOL_OR_TOGGLE_DEFAULT_TOGGLE = BOOL / TOGGLE
BOOL_OR_TOGGLE_DEFAULT_TRUE = BOOL / TOGGLE
BOOL_OR_TOGGLE_DEFAULT_FALSE = BOOL / TOGGLE
BOOL_DEFAULT_TRUE = BOOL
BOOL_DEFAULT_FALSE = BOOL

; parsed by strtol
LONGINT = INT

; parsed by CreateFlagString
CONDITIONMASK = [CM_COND_NEG *("," CM_COND_NEG)]
CM_COND_NEG = ["!"] CM_COND
CM_COND = ("AcceptsFocus")
CM_COND =/ ("Focused")
CM_COND =/ ("HasPointer")
CM_COND =/ ("Iconic")
CM_COND =/ ("Visible")
CM_COND =/ ("Overlapped")
CM_COND =/ ("PlacedByButton" [BUTTON])
CM_COND =/ ("PlacedByButton3")
CM_COND =/ ("Raised")
CM_COND =/ ("Sticky")
CM_COND =/ ("StickyAcrossPages")
CM_COND =/ ("StickyAcrossDesks")
CM_COND =/ ("StickyIcon")
CM_COND =/ ("StickyAcrossPagesIcon")
CM_COND =/ ("StickyAcrossDesksIcon")
CM_COND =/ ("Maximized")
CM_COND =/ ("FixedSize")
CM_COND =/ ("FixedPosition")
CM_COND =/ ("HasHandles")
CM_COND =/ ("Iconifiable")
CM_COND =/ ("Maximizable")
CM_COND =/ ("Closable")
CM_COND =/ ("Shaded")
CM_COND =/ ("Transient")
CM_COND =/ ("PlacedByMvwm")
CM_COND =/ ("CurrentDesk")
CM_COND =/ ("CurrentPage")
CM_COND =/ ("CurrentGlobalPage")
CM_COND =/ ("CurrentPageAnyDesk")
CM_COND =/ ("CurrentScreen")
CM_COND =/ ("AnyScreen")
CM_COND =/ ("CurrentGlobalPageAnyDesk")
CM_COND =/ ("CirculateHit")
CM_COND =/ ("CirculateHitIcon")
CM_COND =/ ("CirculateHitShaded")
CM_COND =/ ("State" STATENUM)
CM_COND =/ ("Layer" [INT])
; argument is the layer number; negative values are silently ignored
CM_COND =/ NAMELIST
CM_NAMELIST = NAME *["|" NAME]
CM_NAME = STRING
; up to and excluding next "|"

QUOTED_TOKEN = TOKEN

STATENUM = DIGIT / ("1" DIGIT) / ("2" DIGIT) / "30" / "31"

; Parsed by GetOnePercentArgument()
PERCENT_ARG = INT [PERCENT_ARG_SUFFIX]
PERCENT_ARG_SUFFIX = "p" / "P"
; Parsed by GetTwoPercentArguments()
PERCENT_ARG_PAIR = 2PERCENT_ARG / RECTANGLE_ARGS
; Parsed by GetRectangleArguments()
RECTANGLE_ARGS = INT RECT_CHARACTER INT
RECT_CHARACTER = %x01.09 / %x0b.4f / %x51.6f / %x71.ff
; note: any character except p, P and \n.
DQ_RECT_CHARACTER = %x01.09 / %x0b.4f / %x51.6f / %x71.ff

;; string rules

DQUOTE = %x22 ; "
SQUOTE = %x27 ; '
BQUOTE = %x60 ; `
CQUOTE = %x5c ; \

; any character except \, ", ', `, whitespace, newline
SCHAR_UNQ = %x01.08
SCHAR_UNQ =/ %x0b.1f
SCHAR_UNQ =/ %x21
SCHAR_UNQ =/ %x23.26
SCHAR_UNQ =/ %x28.5b
SCHAR_UNQ =/ %x5d.5f
SCHAR_UNQ =/ %x61.ff

; \ followed by any character except newline
SCHAR_CQ_CHAR = "\" (%x01.09 /%x0b.ff)

; any character except ", whitespace, newline (\ quotes resolved)
SCHAR_DQ = SCHAR_UNQ
SCHAR_DQ =/ SQUOTE
SCHAR_DQ =/ BQUOTE
SCHAR_DQ =/ SCHAR_CQ_CHAR
; any character except ', whitespace, newline (\ quotes resolved)
SCHAR_SQ = SCHAR_UNQ
SCHAR_SQ =/ DQUOTE
SCHAR_SQ =/ BQUOTE
SCHAR_SQ =/ SCHAR_CQ_CHAR
; any character except `, whitespace, newline (\ quotes resolved)
SCHAR_BQ = SCHAR_UNQ
SCHAR_BQ =/ DQUOTE
SCHAR_BQ =/ SQUOTE
SCHAR_BQ =/ SCHAR_CQ_CHAR
; any simple character or one quoted with \
SCHAR_CQ = SCHAR_UNQ
SCHAR_CQ =/ SCHAR_CQ_CHAR

; unquoted string
STRING_UNQ = 1*SCHAR_UNQ
; strings quoted with ", ', `
STRING_DQ = DQUOTE 1*SCHAR_DQ DQUOTE
STRING_SQ = SQUOTE 1*SCHAR_SQ SQUOTE
STRING_BQ = BQUOTE 1*SCHAR_BQ BQUOTE

STRING = 1*(STRING_UNQ / STRING_DQ / STRING_SQ / STRING_BQ)
TOKEN = STRING

; applies only to tokens that are quoted with double, single or back quotes

;; !!! obsolete commands removed in mvwm

CMD_XINERAMA = "Xinerama"
CMD_XINERAMAPRIMARYSCREEN = "XineramaPrimaryScreen"
CMD_XINERAMASLS = "XineramaSls"
CMD_XINERAMASLSSCREENS = "XineramaSlsScreens"
CMD_XINERAMASLSSIZE = "XineramaSlsSize"

;; !!! obsolete commands in fvwm2

CMD_WINDOWFONT = "WindowFont"
CMD_WINDOWSHADEANIMATE = "WindowShadeAnimate"
CMD_WINDOWSDESK = "WindowsDesk"
