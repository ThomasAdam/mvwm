.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.02)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FvwmPerl 1"
.TH FvwmPerl 1 "2009-03-22" "2.5.28 (from cvs)" "Fvwm Modules"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
FvwmPerl \- the fvwm perl manipulator and preprocessor
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
FvwmPerl should be spawned by \fIfvwm\fR\|(1) for normal functionality.
.PP
To run this module, place this command somewhere in the configuration:
.PP
.Vb 1
\&    Module FvwmPerl [params]
.Ve
.PP
or:
.PP
.Vb 1
\&    ModuleSynchronize FvwmPerl [params]
.Ve
.PP
if you want to immediately start to send commands to FvwmPerl.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is intended to extend fvwm commands with the perl scripting power.\  It enables to embed perl expressions in the fvwm config files and construct fvwm commands.
.SH "INVOCATION"
.IX Header "INVOCATION"
If you want to invoke the unique and persistent instanse of FvwmPerl, it is suggested to do this from the \fIStartFunction\fR.\  Calling it from the top is also possible, but involves some issues not discussed here.
.PP
.Vb 1
\&    AddToFunc StartFunction I Module FvwmPerl
.Ve
.PP
There are several command line switches:
.PP
\&\fBFvwmPerl\fR [ \fB\-\-eval\fR line ] [ \fB\-\-load\fR file ] [ \fB\-\-preprocess\fR [ \fB\-\-quote\fR char ] [ \fB\-\-winid\fR wid ] [ \fB\-\-cmd\fR ] [ \fB\-\-nosend\fR ] [ \fB\-\-noremove\fR ] [ line | file ] ] [ \fB\-\-export\fR [names] ] [ \fB\-\-stay\fR ] [ \fB\-\-nolock\fR ] [ alias ]
.PP
Long switches may be abbreviated to short one-letter switches.
.PP
\&\fB\-e\fR|\fB\-\-eval\fR line \- evaluate the given perl code
.PP
\&\fB\-l\fR|\fB\-\-load\fR file \- evaluate perl code in the given file
.PP
\&\fB\-p\fR|\fB\-\-preprocess\fR [ file ] \- preprocess the given fvwm config file
.PP
The following 5 options are only valid together with \fB\-\-preprocess\fR option.
.PP
\&\fB\-c\fR|\fB\-\-cmd\fR line \- an fvwm command to be preprocessed instead of file
.PP
\&\fB\-q\fR|\fB\-\-quote\fR char \- change the default '%' quote
.PP
\&\fB\-w\fR|\fB\-\-winid\fR wid \- set explicit window context (should begin with digit, may be in oct or hex form; this window id overwrites implicit window context if any)
.PP
\&\fB\-\-nosend\fR \- do not send the preprocessed file to \fIfvwm\fR for \fBRead\fRing, the default is send. Useful for preprocessing non fvwm config files.
.PP
\&\fB\-\-noremove\fR \- do not remove the preprocessed file after sending it to \fIfvwm\fR for \fBRead\fRing, the default is remove. Useful for debugging.
.PP
\&\fB\-x\fR|\fB\-\-export\fR [names] \- define fvwm shortcut functions (by default, two functions named \*(L"Eval\*(R" and \*(L".\*(R").\  This option implies \fB\-\-stay\fR.
.PP
\&\fB\-s\fR|\fB\-\-stay\fR \- continues an execution after \fB\-\-eval\fR, \fB\-\-load\fR or \fB\-\-preprocess\fR are processed.\  By default, the module is not persistent in this case, i.e. \fB\-\-nostay\fR is assumed.
.PP
\&\fB\-\-nolock\fR \- when one of the 3 action options is given, this option causes unlocking \fIfvwm\fR immediately. By default the requested action is executed synchronously; this only makes difference when invoked like:
.PP
.Vb 1
\&    ModuleSynchronous FvwmPerl \-\-preprocess someconfig.ppp
.Ve
.PP
If \fB\-\-nolock\fR is added here, \fBModuleSynchronous\fR returns immediately. Note that \fBModule\fR returns immediately regardless of this option.
.SH "USING ALIAS"
.IX Header "USING ALIAS"
Aliases allow to have several module invocations and work separately with all invocations, here is an example:
.PP
.Vb 4
\&    ModuleSynchronous FvwmPerl FvwmPerl\-JustTest
\&    SendToModule FvwmPerl\-JustTest eval $a = 2 + 2; $b = $a
\&    SendToModule FvwmPerl\-JustTest eval cmd("Echo 2 + 2 = $b")
\&    KillModule FvwmPerl FvwmPerl\-JustTest
.Ve
.SH "PREPROCESSING EXAMPLE"
.IX Header "PREPROCESSING EXAMPLE"
One of the effective proprocessing solutions is to pass the whole fvwm configuration with embeded perl code to \*(L"FvwmPerl \-\-preprocess\*(R". An alternative approach is to write a perl script that produces fvwm commands and sends them for execution, this script may be loaded using \*(L"FvwmPerl \-\-load\*(R". There are hovewer intermediate solutions that preprocess only separate configuration lines (or alternatively, execute separate perl commands that produce fvwm commands).
.PP
The following code snippet adds ability of arithmetics and string scripting to certain lines that need this. To use this, you want to start FvwmPerl as your first command so that other commands may be asked to be preprosessed.
.PP
.Vb 1
\&    ModuleSynchronize FvwmPerl
\&
\&    AddToFunc .
\&    + I SendToModule FvwmPerl preprocess \-c \-\- $*
\&
\&    . Exec exec xterm \-name xterm\-%{++$i}%   # use unique name
\&
\&    . GotoDesk 0 %{ $[desk.n] + 1 }%         # go to next desk
\&
\&    . Exec exec %{ \-x "/usr/bin/X11/aterm" ? "aterm" : "xterm" }% \-sb
\&
\&    # center a window
\&    Next (MyWindow) . Move \e
\&      %{($WIDTH \- $[w.width]) / 2}%p %{($HEIGHT \- $[w.height]) / 2}%p
\&
\&    . Exec exec xmessage %{2 + 2}%           # simple calculator
\&
\&    . %{main::show_message(2 + 2, "Yet another Calculator"); ""}%
.Ve
.SH "ACTIONS"
.IX Header "ACTIONS"
There are several actions that FvwmPerl may perform:
.IP "\fBeval\fR perl-code" 4
.IX Item "eval perl-code"
Evaluate a line of perl code.
.Sp
A special function \fBcmd(\fR\*(L"command\*(R"\fB)\fR may be used in perl code to send commands back to fvwm.
.Sp
If perl code contains an error, it is printed to the standard error stream with the \fI[FvwmPerl][eval]:\fR header prepended.
.IP "\fBload\fR file-name" 4
.IX Item "load file-name"
Load a file of perl code. If the file is not fully qualified, it is searched in the user directory \f(CW$FVWM_USERDIR\fR (usually ~/.fvwm) and the system wide data directory \f(CW$FVWM_DATADIR\fR.
.Sp
A special function \fBcmd(\fR\*(L"command\*(R"\fB)\fR may be used in perl code to send commands back to fvwm.
.Sp
If perl code contains an error, it is printed to the standard error stream with the \fI[FvwmPerl][load]:\fR header prepended.
.IP "\fBpreprocess\fR [\-q|\-\-quote char] [\-c|\-\-cmd] [\fIline\fR | \fIfile\fR]" 4
.IX Item "preprocess [-q|--quote char] [-c|--cmd] [line | file]"
Preprocess fvwm config \fIfile\fR or (if \-\-cmd is given) \fIline\fR. This file contains lines that are not touched (usually fvwm commands) and specially preformatted perl code that is processed and replaced. Text enclosed in \fB%{\fR ... \fB}%\fR delimiters, that may start anywhere on the line and end anywhere on the same or another line, is perl code.
.Sp
The \fIquote\fR parameter changes perl code delimiters.\  If a single char is given, like '@', the delimiters are \fB@{\fR ... \fB}@\fR. If the given quote is 2 chars, like \fB<>\fR, the quotes are \fB<{\fR ... \fB}>\fR
.Sp
The perl code is substituted for the result of its evaluation. I.e. %{$a = \*(L"c\*(R"; ++$a}% is replaced with \*(L"d\*(R".
.Sp
The evaluation is unlike \fBeval\fR and \fBload\fR is done under the package PreprocessNamespace and without \fIuse strict\fR, so you are free to use any variable names without fear of conflicts. Just don't use uninitialized variables to mean undef or empty list (they may be in fact initialized by the previous preprocess action), and do a clean-up if needed. The variables and function in the \fImain\fR package are still available, like ::\fIcmd()\fR or ::\fIskip()\fR, but it is just not a good idea to access them while preprocessing.
.Sp
There is a special function \fBinclude\fR(\fIfile\fR) that loads a file, preprocesses it and returns the preprocessed result. Avoid recursion.
.Sp
If any embedded perl code contains an error, it is printed to the standard error stream and prepended with the \fI[FvwmPerl][preprocess]:\fR header. The result of substitution is empty in this case.
.Sp
The following variables may be used in the perl code:
.Sp
\&\f(CW$USER\fR, \f(CW$DISPLAY\fR, \f(CW$WIDTH\fR, \f(CW$HEIGHT\fR, \f(CW$FVWM_VERSION\fR, \f(CW$FVWM_MODULEDIR\fR, \f(CW$FVWM_DATADIR\fR, \f(CW$FVWM_USERDIR\fR
.Sp
The following line based directives are recognized when preprocessing. They are processed after the perl code (if any) is substituted.
.RS 4
.IP "%\fBRepeat\fR \fIcount\fR" 4
.IX Item "%Repeat count"
Causes the following lines to be repeated \fIcount\fR times.
.IP "%\fBModuleConfig\fR \fImodule-name\fR [ destroy ]" 4
.IX Item "%ModuleConfig module-name [ destroy ]"
Causes the following lines to be interpreted as the given module configuration. If \*(L"destroy\*(R" is specified the previous module configuration is destroyed first.
.IP "%\fBPrefix\fR \fIprefix\fR" 4
.IX Item "%Prefix prefix"
Prefixes the following lines with the quoted \fIprefix\fR.
.IP "%\fBEnd\fR any-optional-comment" 4
.IX Item "%End any-optional-comment"
Ends any of the directives described above, may be nested.
.RE
.RS 4
.Sp
Examples:
.Sp
.Vb 6
\&    %Prefix "AddToFunc SwitchToWindow I"
\&        Iconify off
\&        WindowShade off
\&        Raise
\&        WarpToWindow 50 50
\&    %End
\&
\&    %ModuleConfig FvwmPager destroy
\&        Colorset 0
\&        Font lucidasans\-10
\&        DeskTopScale 28
\&        MiniIcons
\&    %End ModuleConfig FvwmPager
\&
\&    %Prefix "All (MyWindowToAnimate) ResizeMove "
\&    100 100 %{($WIDTH \- 100) / 2}% %{($HEIGHT \- 100) / 2}%
\&    %Repeat %{$count}%
\&    br w+2c w+2c w\-1c w\-1c
\&    %End
\&    %Repeat %{$count}%
\&    br w\-2c w\-2c w+1c w+1c
\&    %End
\&    %End Prefix
.Ve
.Sp
Additional preprocess parameters \-\-nosend and \-\-noremove may be given too. See their description at the top.
.RE
.IP "\fBexport\fR [\fIfunc-names\fR]" 4
.IX Item "export [func-names]"
Send to \fIfvwm\fR the definition of shortcut functions that help to activate different actions of the module (i.e. \fBeval\fR, \fBload\fR and \fBpreprocess\fR).
.Sp
Function names (\fIfunc-names\fR) may be separated by commas or/and whitespace. By default, two functions \*(L"Eval\*(R" and \*(L".\*(R" are assumed.
.Sp
The actual action defined in a function is guessed from the function name if possible, where function name \*(L".\*(R" is reserved for \fBpreprocess\fR action.
.Sp
For example, any of these two fvwm commands
.Sp
.Vb 2
\&   SendToModule MyPerl export PerlEval,PP
\&   FvwmPerl \-\-export PerlEval,PP MyPerl
.Ve
.Sp
define the following two shortcut functions:
.Sp
.Vb 4
\&  DestroyFunc PerlEval
\&  AddToFunc I SendToModule MyPerl eval $*
\&  DestroyFunc PP
\&  AddToFunc I SendToModule MyPerl preprocess \-c \-\- $*
.Ve
.PP
These 4 actions may be requested in one of 3 ways: 1) in the command line when FvwmPerl is invoked (in this case FvwmPerl is short-lived unless \fB\-\-stay\fR or \fB\-\-export\fR is also given), 2) by sending the corresponding message in fvwm config using SendToModule, 3) by calling the corresponding perl function in perl code.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
There are several functions that perl code may call:
.ie n .IP "\fBcmd(\fR\fI\fI$fvwm_command\fI\fR\fB)\fR" 4
.el .IP "\fBcmd(\fR\fI\f(CI$fvwm_command\fI\fR\fB)\fR" 4
.IX Item "cmd($fvwm_command)"
In case of \fBeval\fR or \fBload\fR \- send back to fvwm a string \fI\f(CI$fvwm_command\fI\fR. In case of \fBpreprocess\fR \- append a string \fI\f(CI$fvwm_command\fI\fR to the output of the embedded perl code.
.ie n .IP "\fBdo_eval(\fR\fI\fI$perl_code\fI\fR\fB)\fR" 4
.el .IP "\fBdo_eval(\fR\fI\f(CI$perl_code\fI\fR\fB)\fR" 4
.IX Item "do_eval($perl_code)"
This function is equivalent to the \fBeval\fR functionality on the string \fI\f(CI$perl_code\fI\fR, described above.
.ie n .IP "\fBload(\fR\fI\fI$filename\fI\fR\fB)\fR" 4
.el .IP "\fBload(\fR\fI\f(CI$filename\fI\fR\fB)\fR" 4
.IX Item "load($filename)"
This function is equivalent to the \fBload\fR functionality on the file \f(CW$filename\fR, described above.
.ie n .IP "\fBpreprocess(\fR\fI\fI@params\fI, [""\-c \f(CI$command\fI""] [$filename]\fR\fB)\fR" 4
.el .IP "\fBpreprocess(\fR\fI\f(CI@params\fI, [``\-c \f(CI$command\fI''] [$filename]\fR\fB)\fR" 4
.IX Item "preprocess(@params, [-c $command] [$filename])"
This function is equivalent to the \fBpreprocess\fR functionality with the given parameters and the file \f(CW$filename\fR described above.
.ie n .IP "\fBexport(\fR\fI\fI$func_names\fI, [$do_unexport]\fR\fB)\fR" 4
.el .IP "\fBexport(\fR\fI\f(CI$func_names\fI, [$do_unexport]\fR\fB)\fR" 4
.IX Item "export($func_names, [$do_unexport])"
This function is equivalent to the \fBexport\fR functionality with the given \f(CW$func_names\fR, described above. May also \fBunexport\fR the function names if the second parameter is true.
.Sp
Function names should be separated by commas or/and whitespace. If \fI\f(CI$func_names\fI\fR is empty then functions \*(L"Eval\*(R" and \*(L".\*(R" are assumed.
.IP "\fB\f(BIstop()\fB\fR" 4
.IX Item "stop()"
Terminates the module.
.IP "\fB\f(BIskip()\fB\fR" 4
.IX Item "skip()"
Skips the rest of the event callback code, i.e. the module returns to listen to new module events.
.IP "\fB\f(BIunlock()\fB\fR" 4
.IX Item "unlock()"
Unsynchronizes the event callback from fvwm. This may be useful to prevent deadlocks, i.e. usually fvwm kills the non-responding module if the event callback is not finished in \fIModuleTimeout\fR seconds. This prevents it.
.Sp
This example causes FvwmPerl to suspend its execution for one minute:
.Sp
.Vb 1
\&    SendModule FvwmPerl eval unlock(); sleep(60);
.Ve
.Sp
However, verify that there is no way a new message is sent by fvwm while the module is busy, and fvwm stays locked on this new message for too long. See also the \fBdetach\fR solution if you need long lasting operations.
.IP "\fB\f(BIdetach()\fB\fR" 4
.IX Item "detach()"
Forks and detaches the rest of the event callback code from the main process. This may be useful to prevent killing the module if its event callback should take a long time to complete and it may be done in the detached child. The detached child may still send commands to fvwm (don't rely on this), but not receive the events of course, it exits immediately after the callback execution is finished.
.Sp
If you use \fIdetach()\fR, better only send commands to fvwm in one process (the main one or the detached one), doing otherwise may often cause conflicts.
.ie n .IP "\fBshow_message(\fR$msg\fR, \f(CW$title\fR[, \f(CW$use_stderr_too\fR=1]\fB)" 4
.el .IP "\fBshow_message(\fR\f(CW$msg\fR, \f(CW$title\fR[, \f(CW$use_stderr_too\fR=1]\fB)\fR" 4
.IX Item "show_message($msg, $title[, $use_stderr_too=1])"
Shows a dialog window with the given message, using whichever X tool is found in the system.
.Sp
See \fBFVWM::Module::Toolkit\fR::\fBshow_message\fR for more information.
.SH "VARIABLES"
.IX Header "VARIABLES"
There are several global variables in the \fImain\fR namespace that may be used in the perl code:
.PP
.Vb 3
\&    $a, $b, ... $h
\&    @a, @b, ... @h
\&    %a, %b, ... %h
.Ve
.PP
They all are initialized to the empty value and may be used to store a state between different calls to FvwmPerl actions (\fBeval\fR and \fBload\fR).
.PP
If you need more readable variable names, either write \*(L"no strict 'vars';\*(R" at the start of every perl code or use a hash for this, like:
.PP
.Vb 1
\&    $h{id} = $h{first_name} . " " . $h{second_name}
.Ve
.PP
or use a package name, like:
.PP
.Vb 2
\&    @MyMenu::terminals = qw( xterm rxvt );
\&    $MyMenu::item_num = @MyMenu::terminals;
.Ve
.PP
There may be a configuration option to turn strictness on and off.
.SH "MESSAGES"
.IX Header "MESSAGES"
FvwmPerl may receive messages using the fvwm command SendToModule. The names, meanings and parameters of the messages are the same as the corresponding actions, described above.
.PP
Additionally, a message \fBstop\fR causes a module to quit.
.PP
A message \fBunexport\fR [\fIfunc-names\fR] undoes the effect of \fBexport\fR, described in the \s-1ACTIONS\s0 section.
.PP
A message \fBdump\fR dumps the contents of the changed variables (not yet).
.SH "EXAMPLES"
.IX Header "EXAMPLES"
A simple test:
.PP
.Vb 7
\&    SendToModule FvwmPerl eval $h{dir} = $ENV{HOME}
\&    SendToModule FvwmPerl eval load($h{dir} . "/test.fpl")
\&    SendToModule FvwmPerl load $[HOME]/test.fpl
\&    SendToModule FvwmPerl preprocess config.ppp
\&    SendToModule FvwmPerl export Eval,PerlEval,PerlLoad,PerlPP
\&    SendToModule FvwmPerl unexport PerlEval,PerlLoad,PerlPP
\&    SendToModule FvwmPerl stop
.Ve
.PP
The following example handles root backgrounds in fvwmrc. All these commands may be added to StartFunction.
.PP
.Vb 1
\&    Module FvwmPerl \-\-export PerlEval
\&
\&    # find all background pixmaps for a later use
\&    PerlEval $a = $ENV{HOME} . "/bg"; \e
\&      opendir DIR, $a; @b = grep { /xpm$/ } readdir(DIR); closedir DIR
\&
\&    # build a menu of background pixmaps
\&    AddToMenu MyBackgrounds "My Backgrounds" Title
\&    PerlEval foreach $b (@b) \e
\&      { cmd("AddToMenu MyBackgrounds \*(Aq$b\*(Aq Exec fvwm\-root $a/$b") }
\&
\&    # choose a random background to load on start\-up
\&    PerlEval cmd("AddToFunc \e
\&      InitFunction + I Exec exec fvwm\-root $a/" . $b[int(random(@b))])
.Ve
.SH "ESCAPING"
.IX Header "ESCAPING"
\&\fBSendToModule\fR just like any other fvwm commands expands several dollar prefixed variables.\  This may clash with the dollars perl uses. You may avoid this by prefixing SendToModule with a leading dash. The following 2 lines in each pair are equivalent:
.PP
.Vb 2
\&    SendToModule FvwmPerl eval $$d = "$[DISPLAY]"
\&    \-SendToModule FvwmPerl eval $d = "$ENV{DISPLAY}"
\&
\&    SendToModule FvwmPerl eval \e
\&        cmd("Echo desk=$d, display=$$d")
\&    SendToModule FvwmPerl preprocess \-c \e
\&        Echo desk=%("$d")%, display=%{$$d}%
.Ve
.PP
Another solution to avoid escaping of special symbols like dollars and backslashes is to create a perl file in ~/.fvwm and then load it:
.PP
.Vb 1
\&    SendToModule FvwmPerl load build\-menus.fpl
.Ve
.PP
If you need to preprocess one command starting with a dash, you should precede it using \*(L"\-\-\*(R".
.PP
.Vb 8
\&    # this prints the current desk, i.e. "0"
\&    SendToModule FvwmPerl preprocess \-c Echo "$%{$a = "c"; ++$a}%"
\&    # this prints "$d"
\&    SendToModule FvwmPerl preprocess \-c \-\- \-Echo "$%{"d"}%"
\&    # this prints "$d" (SendToModule expands $$ to $)
\&    SendToModule FvwmPerl preprocess \-c \-\- \-Echo "$$%{"d"}%"
\&    # this prints "$$d"
\&    \-SendToModule FvwmPerl preprocess \-c \-\- \-Echo "$$%{"d"}%"
.Ve
.PP
Again, it is suggested to put your command(s) into file and preprocess the file instead.
.SH "CAVEATS"
.IX Header "CAVEATS"
FvwmPerl being written in perl and dealing with perl, follows the famous perl motto: \*(L"There's more than one way to do it\*(R", so the choice is yours.
.PP
Here are more pairs of equivalent lines:
.PP
.Vb 2
\&    Module FvwmPerl \-\-load "my.fpl" \-\-stay
\&    Module FvwmPerl \-e \*(Aqload("my.fpl")\*(Aq \-s
\&
\&    SendToModule FvwmPerl preprocess \-\-quote \*(Aq@\*(Aq my.ppp
\&    SendToModule FvwmPerl eval preprocess({quote => \*(Aq@\*(Aq}, "my.ppp");
.Ve
.PP
Warning, you may affect the way FvwmPerl works by evaluating appropriate perl code, this is considered a feature not a bug.\  But please don't do this, write your own fvwm module in perl instead.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The \fIfvwm\fR\|(1) man page describes all available commands.
.PP
Basically, in your perl code you may use any function or class method from the perl library installed with fvwm, see the man pages of perl packages \fBGeneral::FileSystem\fR, \fBGeneral::Parse\fR and \fBFVWM::Module\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Mikhael Goikhman <migo@homemail.com>.
